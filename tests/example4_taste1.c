/* Buildsupport is (c) 2008-2016 European Space Agency
 * contact: maxime.perrotin@esa.int
 * License is LGPL, check LICENSE file */
/* 
 * build_c_glue.c
 * Generate vm_if.c/h and invoke_ri.c
 * (functions interfacing with the middleware)
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <sys/stat.h>

#include "my_types.h"
#include "practical_functions.h"
#include "c_ast_construction.h"

static FILE *vm_if     = NULL,
            *invoke_ri = NULL,
            *vm_if_h   = NULL;

static int count_calling_threads = 0;

// Brave FPGA allows to have dual implementation of functions (VHDL and native)
// They are detected the AADL property "FPGA_Configurations" is set
static bool brave_fpga = false;

/* Adds header to vm_if files */
void c_preamble(FV * fv)
{
    int hasparam = 0;

    /* Check if any interface needs ASN.1 types */
    FOREACH(i, Interface, fv->interfaces, {
            CheckForAsn1Params(i, &hasparam);});

    fprintf(vm_if, "%s", do_not_modify_warning);

    fprintf(vm_if_h, "%s", do_not_modify_warning);

    fprintf(vm_if_h, "#ifndef VM_IF_%s\n", fv->name);
    fprintf(vm_if_h, "#define VM_IF_%s\n\n", fv->name);

    fprintf(vm_if, "#ifdef __unix__\n"
                   "    #include <stdlib.h>\n"
                   "    #include <stdio.h>\n"
                   "#else\n"
                   "    typedef unsigned size_t;\n"
                   "#endif\n\n");

    fprintf(vm_if_h, "#ifdef __cplusplus\n"
            "extern \"C\" {\n" "#endif\n\n");

    fprintf(vm_if, "#include \"%s_vm_if.h\"\n\n", fv->name);

    if (c == fv->language || cpp == fv->language) {
        fprintf(vm_if, "#include \"%s.h\"\n\n", fv->name);
    }
    else if (gui == fv->language) {
        fprintf(vm_if, "#include \"%s_gui_header.h\"\n\n", fv->name);
    }
    else if (rtds == fv->language) {
        fprintf(vm_if, "#include \"glue_%s.h\"\n\n", fv->name);
    }
    else if (micropython == fv->language) {
        fprintf(vm_if, "#include \"%s_mpy_bindings.h\"\n\n", fv->name);
    }

    if (hasparam) {
        fprintf(vm_if,   "#include \"C_ASN1_Types.h\"\n\n");
        fprintf(vm_if_h, "#include \"C_ASN1_Types.h\"\n\n");

    }

    fprintf(vm_if, "void init_%s()\n{\n", fv->name);

    fprintf(vm_if_h,
            "/*\n * Function initialization:\n"
            " * Calls all dependent user (or GUI) startup code - including sychronous RI\n"
            "*/\n" "void init_%s();\n\n", fv->name);

    /* 
     * Define the main C initialization function
     * It calls the "startup()" user-code function only once
     * There is a protection (init static variable) that is needed
     * when using Po-Hi-C to make sure that the function is executed
     * only once. In Ada, it is not necessary because this function is
     * called only during the elaboration phase of the Ada wrapper, and
     * elaboration is done only once.
     * EDIT (MP 10/01/11): In Ada when using PO-HI-C we must call adainit()
     * which is generated by gnatmake in orchestration phase
     * EDIT (MP 08/02/11): Commented the if (USE_PO_HI_C) that prevented
     * the barrier from being generated with POHIAda. The init function is
     * not called during the elaboration of the Ada wrapper! It is called
     * at the thread startup.
     * EDIT (MP 19/11/12) Removed the barrier that prevented from calling
     * the init function of the remote FVs if the language was Ada.
     */
    fprintf(vm_if, "    static int init = 0;\n\n"
                   "    if (!init) {\n"
                   "        init = 1;\n");

    /* Call the user-defined startup function (or GUI startup)
     * Except for Ada functions - that have startup in elaboration */
    if (ada != fv->language && qgenada != fv->language && qgenc != fv->language) {
        fprintf(vm_if, "        %s_startup();\n", fv->name);
    }

    /* Add a call to QGen init function, if it exists in generated code*/
    FOREACH(i, Interface, fv->interfaces, {
        if ((RI == i->direction) && (i->distant_qgen != NULL)) {
            if (NULL != i->distant_qgen->qgen_init)
                fprintf(vm_if, "        %s;\n", i->distant_qgen->qgen_init);
        }
    });

    /*
     * If this function is a thread and we are using Po-Hi-C, we
     * must call the initialization function of all dependent
     * synchronous functions. Several threads can be connected
     * to a given sync function, but multiple execution of their
     * startup() function is prevented by the "init" barrier
     * (see just above).
     */
    /*
     * Edit (MP 27/06/11):
     * This must NOT be limited to threads - sync functions
     * must also call the init function of their offsprings.
     * (Auto-generated threads do not have any init_ function)
     */
    if (USE_PO_HI_C(fv)) {

        FOREACH(i, Interface, fv->interfaces, {
                if (RI == i->direction && synch == i->synchronism) {
                    fprintf(vm_if,
                        "        extern void init_%s();\n"
                        "        init_%s();\n",
                        i->distant_fv, 
                        i->distant_fv);}
                }
        );
    }

    fprintf(vm_if, "    }\n");

    if (ada == fv->language || qgenada == fv->language) {
        if (USE_PO_HI_C(fv)) {
            fprintf(vm_if, "    /* Calling Ada initialization code */\n"
                           "    adainit();\n");
            fprintf(vm_if_h, "extern void adainit();\n");
        }
    }

    fprintf(vm_if, "}\n\n");
}

/* Creates vm_if.c  */
int Init_C_Glue_Backend(FV * fv)
{
    char *path = NULL;
    char *filename = NULL;

    if (NULL != fv->system_ast->context->output) {
        build_string(&path, fv->system_ast->context->output,
                     strlen(fv->system_ast->context->output));
    }

    build_string(&path, fv->name, strlen(fv->name));

    filename = make_string("%s_vm_if.h", fv->name);

    create_file(path, filename, &vm_if_h);
    filename[strlen(filename) - 1] = 'c';
    create_file(path, filename, &vm_if);


    free(path);
    assert(NULL != vm_if && NULL != vm_if_h);

    c_preamble(fv);

    return 0;
}


void close_c_gluefiles()
{
    close_file(&vm_if);
    if (NULL != vm_if_h) {
        fprintf(vm_if_h,
                "#ifdef __cplusplus\n" 
                "}\n"
                "#endif\n\n"
                "#endif\n");

    }
    close_file(&vm_if_h);
    close_file(&invoke_ri);
}

/* Add a Provided interface. Can contain in and out parameters */
void add_PI_to_c_vm_if(Interface * i)
{
    char *fcn_proto = NULL;
    bool comma = false;

    if (NULL == vm_if)
        return;

    /* a. function name */
    fcn_proto = make_string("void %s_%s (", i->parent_fv->name, i->name);

    /* b. for each IN param, add "void *pmy_inparam, size_t size_my_inparam" */
    FOREACH(p, Parameter, i->in, {
            fcn_proto = make_string("%s%svoid *pmy_%s, size_t size_my_%s",
                                    fcn_proto,
                                    (p != i->in->value) ? ", " : "",
                                    p->name, p->name);}
    );

    /* c. for each OUT param, add "void *pmy_outparam, size_t *size_my_outparam" */
    FOREACH(p, Parameter, i->out, {
        fcn_proto = make_string("%s%svoid *pmy_%s, size_t *psize_my_%s",
                                fcn_proto,
                                (p != i->out->value || (p == i->out->value
                                    && NULL != i->in)) ? ", " : "",
                                p->name,
                                p->name);}
    );

    fprintf(vm_if, "%s)\n{\n", fcn_proto);
    fprintf(vm_if_h, "%s);\n", fcn_proto);
    free(fcn_proto);

    /* d. For each IN param, declare a variable to put the DECODED data.
     *    Variable is static for all interface but unprotected ones.
     */

    if (NULL != i->in) {
        fprintf(vm_if,
                "    /* Decoded input variable(s): developer can use them */\n");
    }

    FOREACH(p, Parameter, i->in, {
        fprintf(vm_if, "    %sasn1Scc%s IN_%s;\n",
                       unprotected != i->rcm? "static ": "",
                       p->type,
                       p->name);
        }
    );

    /* e. For each OUT param, declare a variable that the user can fill
     *    prior to encoding. Variable is static except for unprotected
     *    interfaces (that would lead to race conditions) */
    if (NULL != i->out) {
        fprintf(vm_if,
                "\n    /* Output variable(s): developer has to fill them */\n");
    }

    FOREACH(p, Parameter, i->out, {
        fprintf(vm_if, "    %sasn1Scc%s OUT_%s;\n",
                       unprotected != i->rcm? "static ": "",
                       p->type,
                       p->name);
        }
    );

    /* f. In case of linux platform, memset to 0 all parameters
     *    !! This is only needed to avoid valgrind warnings !!
     *    Unnecessary for flight platform because it consumes CPU for nothing
    */
    if (NULL != i->in || NULL != i->out) {
        fprintf(vm_if, "\n#ifdef __unix__\n");
        FOREACH(p, Parameter, i->in, {
                fprintf(vm_if, "    asn1Scc%s_Initialize(&IN_%s);\n",
                        p->type, p->name);
                }
        );
        FOREACH(p, Parameter, i->out, {
                fprintf(vm_if,
                        "    asn1Scc%s_Initialize(&OUT_%s);\n",
                        p->type, p->name);
                }
        );

        fprintf(vm_if, "#endif\n");
    }

    /* g. Decode each IN param */
    if (NULL != i->in) {
        fprintf(vm_if, "\n    /* Decode each input parameter */\n");
    }

    FOREACH(p, Parameter, i->in, {
        fprintf(vm_if,
                "    if (0 != Decode_%s_%s (&IN_%s, pmy_%s, size_my_%s)) {\n"
                "        #ifdef __unix__\n"
                "            printf(\"\\nError Decoding %s\\n\");\n"
                "        #endif\n"
                "        return;\n"
                "    }\n\n",
                BINARY_ENCODING(p),
                p->type, p->name, p->name, p->name, p->type);
    });

    if (brave_fpga) {
        fprintf(vm_if, "   /* Calling Brave VHDL dispatcher function */\n"
                       "   if (0 == %s_%s_Brave_Dispatch (",
                       i->parent_fv->name, i->name);
        comma = false;
        // add encoded (raw) in/out params, if vhdl modes apply,
        // corresponding B mapper will generate code to decode them
        FOREACH(p, Parameter, i->in, {
           fprintf(vm_if, "%spmy_%s, size_my_%s",
                           comma ? ", ":"",
                           p->name,
                           p->name);
           comma = true;
        });
        FOREACH(p, Parameter, i->out, {
           fprintf(vm_if, "%spmy_%s, psize_my_%s",
                           comma ? ", ":"",
                           p->name,
                           p->name);
           comma = true;
        });
        // dispatch function shall return 0 if VHDL code was executed
        fprintf(vm_if, ")) return;\n\n");
    }

    if (qgenc == i->parent_fv->language) {
        /* h. Add a call to the user-defined function passing the decoded input as parameter */
        fprintf(vm_if, "    /* Call to QGenc comp function */\n");
        fprintf(vm_if, "    %s_comp (", i->name);

        /* Add the external QGenc comp function declaration in the header file */
        fprintf(vm_if_h, "extern void %s_comp (", i->name);
    } else {
        /* h. Add a call to the user-defined function passing the decoded input as parameter */
        fprintf(vm_if, "    /* Call to User-defined function */\n");
        fprintf(vm_if, "    %s_PI_%s (", i->parent_fv->name, i->name);

        /* Add the external PI function declaration in the header file */
        fprintf(vm_if_h, "extern void %s_PI_%s (", i->parent_fv->name, i->name);
    }

    comma = false;
    FOREACH (p, Parameter, i->in, {
        fprintf(vm_if_h, "%sconst asn1Scc%s *",
                         comma ? ", " : "",
                         p->type);
        comma = true;
    });
    FOREACH (p, Parameter, i->out, {
        fprintf(vm_if_h, "%sasn1Scc%s *",
                         comma ? ", " : "",
                         p->type);
        comma = true;
    });
    fprintf(vm_if_h, ");\n");

    // Add parameters to the call of the functions
    comma = false;
    FOREACH(p, Parameter, i->in, {
        fprintf(vm_if, "%s&IN_%s",
                (true == comma) ? ", " : "", p->name); comma = true;
        }
    );

    comma = false;
    FOREACH(p, Parameter, i->out, {
        if (NULL != i->in) comma = true;
        fprintf(vm_if, "%s&OUT_%s",
                (true == comma) ? ", " : "", p->name); comma = true;
        }
    );

    fprintf(vm_if, ");\n\n");  // Enf of call to user code

    /* i. Encode each OUT param */
    if (NULL != i->out) {
        fprintf(vm_if, "    /* Encode each output parameter */\n\n");
    }

    FOREACH(p, Parameter, i->out, {
        fprintf(vm_if,
                "    *psize_my_%s = Encode_%s_%s (pmy_%s, %sasn1Scc%s%s, &OUT_%s);\n",
                p->name,
                BINARY_ENCODING(p),
                p->type,
                p->name,
                (native == p->encoding) ? "sizeof (" : "",
                p->type,
                (native == p->encoding) ? ")" :
                (uper == p->encoding) ?
                "_REQUIRED_BYTES_FOR_ENCODING" :
                "_REQUIRED_BYTES_FOR_ACN_ENCODING", p->name);
        }
    );

    fprintf(vm_if, "}\n");
}

/* Generation of interface functions to allow developer to call RI */
void add_RI_to_c_invoke_ri(Interface * i)
{
    if (NULL == invoke_ri) {
        char *path = NULL;
        int hasparam = 0;

        FOREACH(interface, Interface, i->parent_fv->interfaces, {
                CheckForAsn1Params(interface, &hasparam);
        });

        if (NULL != i->parent_fv->system_ast->context->output) {
            build_string(&path, get_context()->output,
                         strlen(get_context()->output));
        }

        build_string(&path, i->parent_fv->name,
                     strlen(i->parent_fv->name));

        if (-1 == create_file(path, "invoke_ri.c", &invoke_ri)) {
            free(path);
            return;
        }
        else {
            fprintf(invoke_ri,
                    "/* This file was generated automatically: DO NOT MODIFY IT ! */\n\n"
                    "#include <stdlib.h>\n"
                    "#ifdef __unix__\n"
                    "#include <stdio.h>\n");
            if (hasparam) {
                fprintf(invoke_ri,
                        "#include \"PrintTypesAsASN1.h\"\n"
                        "#include \"timeInMS.h\"\n");
            }
            fprintf(invoke_ri, "#endif\n\n");
            if (hasparam)
                fprintf(invoke_ri, "#include \"C_ASN1_Types.h\"\n");
            if (get_context()->polyorb_hi_c) {
                fprintf(invoke_ri,
                        "#include \"%s_polyorb_interface.h\"\n\n",
                        i->parent_fv->name);
            }
            if (qgenc == i->distant_qgen->language)
                fprintf(invoke_ri,
                        "#include \"%s.h\"\n\n",
                        string_to_lower(i->distant_name));
        }
        free(path);
    }


    /* a. function name */

    fprintf(invoke_ri,
            "void %s_RI_%s(",
            i->parent_fv->name,
            i->name);

    /* Add the IN and OUT parameters: */
    FOREACH(p, Parameter, i->in, {
            List_C_Types_And_Params_With_Pointers(p, &invoke_ri);}
    );
    FOREACH(p, Parameter, i->out, {
            List_C_Types_And_Params_With_Pointers(p, &invoke_ri);}
    );

    fprintf(invoke_ri, ")\n{\n");

    /* MSC Tracer-related code */
    FV *receiver_FV = NULL;
    char *receiver_id = NULL, *sender_id = NULL;

    fprintf(invoke_ri, "#ifdef __unix__\n");

    fprintf(invoke_ri, "    static int innerMsc = -1;\n");

    /* Sender or receiver can be in a FV that was created during VT
     * (their name may be computed: fv_FV_pi) - in that case this is not
     * what we want to see in the MSC - we have to retreive the original
     * name, as it was entered by the user in the interface view */
    if (NULL != i->distant_fv) {
        receiver_FV = FindFV(i->distant_fv);

        if (true == receiver_FV->artificial) {
            receiver_id = receiver_FV->original_name;
        }
        else {
            receiver_id = receiver_FV->name;
        }
        if (true == i->parent_fv->artificial) {
            sender_id = i->parent_fv->original_name;
        }
        else {
            sender_id = i->parent_fv->name;
        }
        fprintf(invoke_ri,
                "    if (-1 == innerMsc)\n"
                "        innerMsc = (NULL != getenv(\"TASTE_INNER_MSC\"))?1:0;\n"
                "    if (1 == innerMsc) {\n"
                "        long long msc_time = getTimeInMilliseconds();\n\n");
        FOREACH(p, Parameter, i->in, {
            fprintf(invoke_ri,
                    "        {\n"
                    "            PrintASN1%s (\"INNERDATA: %s::%s::%s\", IN_%s);\n"
                    "        }\n",
                    p->type,
                    i->name,
                    p->type,
                    p->name,
                    p->name);
        });
        fprintf(invoke_ri,
                "        printf (\"\\nINNER: %s,%s,%s,%%lld\\n\", msc_time);\n"
                "        fflush(stdout);\n"
                "    }\n",
                sender_id, receiver_id, i->name);

        fprintf(invoke_ri, "#endif\n\n");
        /* End MSC Tracer-related code */
    }

    if (qgenada == i->distant_qgen->language) {

        /* Add a call to the vm callback function */
        fprintf(invoke_ri, "\n    /* Call to VM callback function */\n");

        fprintf(invoke_ri, "    vm_%s%s_%s(",
                asynch == i->synchronism ? "async_" : "", i->parent_fv->name,
                i->name);

        /* Create the list of parameters */
        FOREACH(p, Parameter, i->in, {
                List_QGen_Param_Names(p, &invoke_ri, i->distant_qgen->language);}
        );

        FOREACH(p, Parameter, i->out, {
                List_QGen_Param_Names(p, &invoke_ri, i->distant_qgen->language);}
        );

        fprintf(invoke_ri, ");\n\n");

    } else if (qgenc == i->distant_qgen->language){

        /* Add a call to the QGenc comp function */
        fprintf(invoke_ri, "\n    /* Call QGenc function */\n");

        fprintf(invoke_ri, "    %s_comp(", i->distant_name);

        /* Create the list of parameters */
        FOREACH(p, Parameter, i->in, {
                List_QGen_Param_Names(p, &invoke_ri, i->distant_qgen->language);}
        );

        FOREACH(p, Parameter, i->out, {
                List_QGen_Param_Names(p, &invoke_ri, i->distant_qgen->language);}
        );

        fprintf(invoke_ri, ");\n\n");

    } else {

        /* d. For each IN and OUT params, declare a static buffer to put encoded data */
        if (NULL != i->in) {
            fprintf(invoke_ri,
                    "    /* Buffer(s) to put the encoded input parameter(s) */\n");
        }
        FOREACH(p, Parameter, i->in, {
            fprintf(invoke_ri,
                    "    static char IN_buf_%s[%sasn1Scc%s%s] = {0};\n    int size_IN_buf_%s=0;\n",
                    p->name,
                    (native == p->encoding) ? "sizeof(" : "",
                    p->type,
                    (native == p->encoding) ? ")" :
                    (uper == p->encoding) ? "_REQUIRED_BYTES_FOR_ENCODING" :
                    "_REQUIRED_BYTES_FOR_ACN_ENCODING",
                    p->name);
        });

        if (NULL != i->out) {
            fprintf(invoke_ri,
                    "\n    /* Buffer(s) for the output parameter(s) */\n");
        }
        FOREACH(p, Parameter, i->out, {
            fprintf(invoke_ri,
                    "    static char OUT_buf_%s[%sasn1Scc%s%s];\n    size_t size_OUT_buf_%s=0;\n",
                    p->name,
                    (native == p->encoding) ? "sizeof(" : "",
                    p->type,
                    (native == p->encoding) ? ")" :
                    (uper == p->encoding) ? "_REQUIRED_BYTES_FOR_ENCODING" :
                    "_REQUIRED_BYTES_FOR_ACN_ENCODING",
                    p->name);
        });

        /* e. Encode each IN param */
        if (NULL != i->in) {
            fprintf(invoke_ri, "\n    /* Encode each input parameter */\n");
        }

        FOREACH(p, Parameter, i->in, {
            fprintf(invoke_ri,
                    "    size_IN_buf_%s = Encode_%s_%s(IN_buf_%s, %sasn1Scc%s%s, IN_%s);\n"
                    "    if (-1 == size_IN_buf_%s) {\n"
                    "#ifdef __unix__\n"
                    "        printf (\"** Encoding error in %s_RI_%s!!\\n\");\n"
                    "#endif\n"
                    "        /* Crash the application due to message loss */\n"
                    "        extern void abort (void);\n"
                    "        abort();\n"
                    "    }\n",
                    p->name,
                    BINARY_ENCODING(p),
                    p->type, p->name,
                    (native == p->encoding) ? "sizeof(" : "",
                    p->type,
                    (native == p->encoding) ? ")" :
                    (uper == p->encoding) ? "_REQUIRED_BYTES_FOR_ENCODING" :
                    "_REQUIRED_BYTES_FOR_ACN_ENCODING",
                    p->name,
                    p->name,
                    i->parent_fv->name,
                    i->name);
        });


        /* f. Add a call to the vm callback function passing the encoded
         *  inputs as parameters */
        fprintf(invoke_ri, "\n    /* Call to VM callback function */\n");
        char *name = make_string("vm_%s%s_%s",
                asynch == i->synchronism ? "async_" : "", i->parent_fv->name,
                i->name);

        /* Declare external function (may be in Ada, so no file to include) */
        fprintf(invoke_ri, "    extern void %s(", name);
        bool comma = false;
        FOREACH(_, Parameter, i->in, {
                (void) _;
                fprintf(invoke_ri, "%svoid *, size_t", comma? ", ": "");
                comma = true;
        });
        FOREACH(_, Parameter, i->out, {
                (void) _;
                fprintf(invoke_ri, "%svoid *, size_t *", comma? ", ": "");
                comma = true;
        });
        fprintf(invoke_ri, ");\n\n");

        fprintf(invoke_ri, "    %s(", name);

        free(name);

        /* Add the IN and OUT parameters */
        FOREACH(p, Parameter, i->in, {
                List_C_Params_And_Size(p, &invoke_ri);}
        );
        FOREACH(p, Parameter, i->out, {
                List_C_Params_And_Size(p, &invoke_ri);}
        );

        fprintf(invoke_ri, ");\n\n");

        /* g. Decode each OUT param */
        if (NULL != i->out) {
            fprintf(invoke_ri, "    /* Decode each output parameter */\n");
        }

        FOREACH(p, Parameter, i->out, {
            fprintf(invoke_ri,
                    "    if (0 != Decode_%s_%s(OUT_%s, OUT_buf_%s, size_OUT_buf_%s)) {\n"\
                    "#ifdef __unix__\n"
                    "        printf(\"\\nError Decoding %s\\n\");\n"
                    "#endif\n"
                    "        return;\n"
                    "    }\n\n",
                    BINARY_ENCODING(p),
                    p->type,
                    p->name,
                    p->name,
                    p->name,
                    p->type);
        });

    }

    fprintf(invoke_ri, "}\n\n");
}

void End_C_Glue_Backend()
{
        close_c_gluefiles();
}

/* Function to process a PI for C language */
void GLUE_C_ProvidedInterface(Interface * i)
{
    if (NULL == i)
        return;
    if (PI == i->direction && !(qgenada == i->parent_fv->language || qgenc == i->parent_fv->language))
        add_PI_to_c_vm_if(i);
}

/* Function to process a RI for non-ObjectGEODE languages */
void GLUE_C_InvokeRI(Interface * i)
{
    if (NULL == i)
        return;
    if (RI == i->direction) {
        /* Discard duplicate RI (with different synchronism) - keep only the sync one */
        if (asynch == i->synchronism) {
            FOREACH(interface, Interface, i->parent_fv->interfaces, {
                if (RI == interface->direction &&
                    !strcmp(interface->name, i->name) &&
                    synch == interface->synchronism)
                {
                    return;
                }
            });
        }
        add_RI_to_c_invoke_ri(i);
    }
}

/* External interface (the one and unique) */
void GLUE_C_Backend(FV * fv)
{
    count_calling_threads = 0;

    if (fv->system_ast->context->onlycv)
        return;

    /* Check, if it's a passive FV, if it can be called by more than one thread.
       This is done in order to generate the appropriate call to vm_... function  */
    if (passive_runtime == fv->runtime_nature) {

        FOREACH(ct, FV, fv->calling_threads, {
                (void) ct; count_calling_threads++;
                }
        );
    }

    // Detect Brave FPGAs (see note at the top of the file)
    brave_fpga = false;
    FOREACH (prop, AADL_Property, fv->properties, {
        char *name = string_to_lower (prop->name);
        //printf("[PROPERTY] %s = %s\n", prop->name, prop->value);
        if (!strcmp(name, "taste_iv_properties::fpga_configurations")) {
            printf("[INFO] Function %s uses BRAVE VHDL modes: %s\n",
                    fv->name,
                    prop->value);
            brave_fpga = true;
        }
    });

    if (false == fv->is_component_type) {
        if (c           == fv->language
         || gui         == fv->language
         || ada         == fv->language
         || vdm         == fv->language
         || qgenada     == fv->language
         || qgenc       == fv->language
         || rtds        == fv->language
         || cpp         == fv->language
         || opengeode   == fv->language
         || micropython == fv->language) {
            Init_C_Glue_Backend(fv);
            FOREACH(i, Interface, fv->interfaces, {
                GLUE_C_ProvidedInterface(i);
            });
        }
    }

   /* for all languages except ObjectGeode (sdl) and Blackbox devices, generate invoke_ri.c */
    if (sdl != fv->language && blackbox_device != fv->language && true != fv->is_component_type) {
        FOREACH(i, Interface, fv->interfaces, {
                GLUE_C_InvokeRI(i);
                }
        );
    }

    End_C_Glue_Backend();
}
